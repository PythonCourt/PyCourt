# === 🏛️ PyCourt 最高法院 - 庭审全程剧本 ===

courtroom:
  supreme_court:
    start: "🏛️ PyCourt 最高法院开庭审理..."
    summary_failed: "❌ 发现 {count} 个违宪行为:"
    summary_passed: "✅ 审查通过，未发现指定范围的违宪行为"

  audit_clerk:
    deps_missing_title: "❌ 发现缺失的强制依赖工具"
    deps_must_install: "🏛️ **[帝国敕令]** 以下工具是审计系统的核心组件，必须安装："
    deps_install_guide: "💡 安装指南："
    deps_refuse_run: "🏛️ 审计系统拒绝在工具不完整的情况下执行！"

# === 🏛️ 各位大法官的判决模板（按法条编号） ===

judges:
  AC001:
    template: |
      🦆 鸭子类型审查官: 检测到 Any 类型滥用
      📌 变量/属性: {target_name}
      📋 违规类型: {annotation_str}
      💡 建议: 避免使用 Any，请为该值引入明确的契约类型（DTO / Protocol / TypedDict）
      🔧 修复示例:
        - 在 `core/dto` 中定义 Pydantic 模型，并在此处引用模型类型
        - 或使用 `TypedDict` / `Protocol` 描述结构，而不是 Any

  AC002:
    template: |
      🦆 类型系统稽查官: 检测到无契约 dict 类型
      📌 变量/属性: {target_name}
      📋 违规类型: {annotation_str}
      💡 建议: 不要直接使用裸 dict，请为 key/value 引入明确的模型或类型别名
      🔧 修复示例:
        - 使用 `RootModel[dict[str, DTO]]` 封装业务字典
        - 为 value 定义 Pydantic DTO / TypedDict / Protocol，并在 dict[...] 中引用

  AC003:
    template: |
      🦆 类型系统稽查官: 检测到 typing.cast 滥用
      📌 表达式: {annotation_str}
      💡 建议: cast 只能作为“无奈之举”，更推荐通过类型签名和契约本身解决问题
      🔧 修复示例:
        - 向上排查数据来源，让类型检查器自然推导出正确类型
        - 如需跨层传递，前往 `core/dto` 定义 DTO / 协议接口，而不是在调用点 cast
        - 对于必要的 cast，请在附近添加 `# cast justified: ...` 注释，记录充分理由

  BC001:
    template: |
      🏛️ 疆域边界审查官: 检测到边界契约违规
      📌 函数: {func}
      📋 违规参数: {name} -> {type}
      💡 建议: 前往 `core/dto` 创建 Pydantic DTO
      🔧 快速修复: 使用 `pydantic.BaseModel` 定义契约类型

  DI001:
    template: |
      🏛️ 依赖倒置审查官: 检测到非法跨组件依赖
      📋 违规导入: {imported_module}
      💡 建议: 通过核心抽象接口访问，或通过依赖注入容器装配依赖
      🔧 快速修复: 在 core/port 定义接口，通过 DI 容器注入实现

  DS001:
    template: |
      🏛️ 文档字符串审查官: 检测到函数缺少文档
      📌 函数: {func}
      💡 建议: 添加描述功能、参数和返回值的文档字符串
      🔧 快速修复: 使用 Google/NumPy 风格的 docstring

  DS002:
    template: |
      🏛️ 文档字符串审查官: 检测到类文档不足
      📌 类: {klass}
      📋 要求: 文档字符串至少 {min_len} 字符
      💡 建议: 添加描述类职责和用法的文档字符串
      🔧 快速修复: 在类定义下方添加三引号文档

  DT001:
    template: |
      🏛️ 时间法官: 检测到 datetime.now()/utcnow() 直接调用
      💡 建议: 通过 ClockPort 接口获取时间
      🔧 快速修复: 注入 ClockPort 依赖，支持虚拟/加速时间线

  HC001:
    template: |
      🏛️ 硬编码审查官: 检测到硬编码字符串
      📌 代码片段: {snippet}
      💡 建议: 按照 docs/CONSTANTS-GUIDE.md 迁移到配置/常量
      🔧 快速修复: 将字面量提取到常量/配置文件中

  HC002:
    template: |
      🏛️ 常量规范审查官: 检测到裸常量导入
      📌 常量: {name}
      💡 建议: 改为导入命名空间类
      🔧 快速修复: 参见 docs/GUIDE/CONSTANTS.md

  HC003:
    template: |
      🏛️ 常量规范审查官: 检测到裸常量定义
      📌 常量: {name}
      💡 建议: 移至 constants 模块并使用命名空间类组织
      🔧 快速修复: 参见 docs/GUIDE/CONSTANTS.md

  HC004:
    template: |
      🏛️ 常量规范审查官: 检测到跨引擎导入业务常量
      📋 来源: {source}
      💡 建议: 如需共享请提升为 System 常量
      🔧 快速修复: 参见 docs/GUIDE/CONSTANTS.md

  HC005:
    template: |
      🏛️ 魔法数值审查官: 检测到可调业务参数以魔法数值形式硬编码
      📌 代码片段: {snippet}
      📋 影响: 阈值/权重/窗口大小等参数一旦写死，将无法通过配置在不同环境或版本中安全调参
      💡 建议: 将该参数迁移到 assets/rules 或 assets/skills 下，由 RulesProviderPort / SkillProviderPort 提供，而不是直接在代码中写死数值
      🔧 快速修复:
        - 在 assets/rules 下为相关任务增加规则字段，或在 assets/skills 下扩展技能配置（如 rating/highlight/memory.slice 等）
        - 在核心代码中通过 RulesProviderPort 或 SkillProviderPort 读取该参数，而不是直接使用字面量
        - 如确需兜底默认值，请集中放入对应的 domain.constants 模块，并在使用处优先读取配置、仅在缺省时回退到默认常量

  LL001:
    template: |
      🏛️ 过度复杂审查官: 检测到函数过长
      📌 函数: {func}
      📋 当前行数: {lines} 行（限制: {limit} 行）
      💡 建议: 拆分为更小、更专注的辅助函数
      🔧 快速修复: 提取子函数，每个函数只做一件事

  LL002:
    template: |
      🏛️ 过度复杂审查官: 检测到函数复杂度过高
      📌 函数: {func}
      📋 圈复杂度: {complexity}（限制: {limit}）
      💡 建议: 审查 if/for/while 分支逻辑，简化控制流
      🔧 快速修复: 使用策略模式、提取子函数等重构

  OU001:
    template: |
      🏛️ 灰色迷雾审查官: 检测到 object 类型使用
      💡 建议: 在 core/dto 或 core/port 定义明确的基类
      🔧 快速修复: 使用 Protocol 或具体类型替代裸 object

  PC001:
    template: |
      🏛️ 参数分类审查官: 检测到运营参数误放常量
      📌 常量: {const_name}
      💡 建议: 将该运营参数从核心常量模块迁移到 assets/rules 目录，由规则提供方统一提供
      🔧 快速修复: 在 assets/rules 下新增规则文件，并通过项目中的 RulesProvider 或等价抽象访问

  PC002:
    template: |
      🏛️ 参数分类审查官: 检测到绕过 RulesProviderPort 直接访问规则资产
      📋 违规代码: {snippet}
      💡 建议: 不要直接 open/Path 访问 assets/rules 或 rules/**，应通过规则提供方加载规则
      🔧 快速修复: 使用项目中的 RulesProvider 抽象 + RuleId 访问规则配置

  RE001:
    template: |
      🏛️ 门面纪律法官: 检测到 __init__.py 过长
      📋 当前行数: {code_count} 行（限制: {max_init_lines} 行）
      💡 建议: 保持精简，避免在门面堆积导入/导出逻辑
      🔧 快速修复: 将实现移至具体模块

  RE002:
    template: |
      🏛️ 门面纪律法官: 检测到业务逻辑定义
      📋 违规类型: {node_type}
      💡 建议: 将实现移至具体模块
      🔧 快速修复: 仅在调用方导入使用

  RE003:
    template: |
      🏛️ 门面纪律法官: 检测到 __init__.py 中不允许的结构
      📋 详情: {detail}
      💡 建议: 门面仅用于说明与极少量元数据
      🔧 快速修复: 将实现移至具体模块，避免在门面堆积导入/导出逻辑

  SK001:
    template: |
      🏛️ 技能使用审查官: 检测到直接硬编码的 Skill ID 字符串
      📌 Skill ID: {skill_id}
      💡 建议: 请通过集中定义的 SkillId 常量或配置引用 Skill，而不是在业务代码中硬编码字符串
      🔧 快速修复: 在资产常量模块或配置中声明 SkillId，并通过 SkillProvider 抽象 + SkillId 访问技能

  SK002:
    template: |
      🏛️ 技能使用审查官: 检测到直接文件访问技能资产
      📋 违规代码: {snippet}
      💡 建议: 不要直接访问 assets/skills 或 SkillsPath.ROOT 下的文件，必须通过 SkillProvider 抽象 + SkillId 访问技能
      🔧 快速修复: 使用项目中的 SkillProvider 抽象进行技能编排

  TC001:
    template: |
      🏛️ 循环依赖审查官: 检测到 TYPE_CHECKING 非法使用
      💡 建议: 将共享依赖提到 core/dto 重构
      🔧 快速修复: 使用 JSONData + 智能工厂解决架构问题

  TP001:
    template: |
      🏛️ 测试纯净度审查官: 检测到单元测试存在非法 I/O 依赖
      📌 位置: {file}:{line}
      📋 违禁导入: {import_stmt}
      💡 建议: 单元测试必须保持 I/O 隔离，请通过端口或测试替身（fake/mock）间接使用依赖。

  TP002:
    template: |
      🏛️ 测试纯净度审查官: 检测到非白名单测试直接依赖 SQLAlchemy
      📌 位置: {file}:{line}
      📋 导入语句: {import_stmt}
      💡 建议: 将数据库相关集成测试集中到 tests/infra/database/contracts/ 下，其余测试应通过端口或仓储协议访问持久化层。

  TP003:
    template: |
      🏛️ 测试纯净度审查官: 检测到仅做存在性检查的伪覆盖测试
      📌 位置: {file}:{line}
      📋 可疑模式: importlib.import_module + hasattr（缺少行为调用）
      💡 建议: 为目标函数/方法编写至少一次真实调用，验证具体行为而不是仅检查存在。

  UW001:
    template: |
      🏛️ Unit of Work 法官: 检测到 RepositoryFactory 违规使用
      📋 违规方法: {method}
      💡 建议: 胶囊发行链路必须进入 Unit of Work
      🔧 快速修复: 使用 uow_factory.create() + uow.repos.* + await uow.commit()
      📚 参考: docs/spec/DATA_UOW.md

  UW002:
    template: |
      🏛️ Unit of Work 法官: 检测到仓储内部调用 commit()
      💡 建议: business repositories 必须 flush-only
      🔧 快速修复: 移除 commit()，由 UnitOfWork.commit() 统一提交
      📚 参考: docs/spec/DATA_UOW.md

  UW003:
    template: |
      🏛️ Unit of Work 法官: 检测到仓储内部调用 rollback()
      💡 建议: business repositories 必须 flush-only
      🔧 快速修复: 移除 rollback()，由 UnitOfWork.rollback() 统一回滚
      📚 参考: docs/spec/DATA_UOW.md

  UW004:
    template: |
      🏛️ Unit of Work 法官: 检测到绕过发行官的胶囊发行行为（直接调用 uow.repos.time_capsule.*）
      💡 规范: 任何胶囊生产者必须通过 TimeCapsuleIssuerPort 在同一 UoW 内完成认证
      🔧 快速修复: 注入 issuer 并调用 issuer.issue_or_reuse(uow=..., dto=...)
      📚 参考: docs/spec/DATA_UOW.md, docs/spec/DATA_CAPSULES.md

  VT001:
    template: |
      🏛️ 向量事务法官: 检测到未支持的 asset_type
      📋 asset_type: {asset_type}
      💡 建议: 在向量提供方实现中为该 asset_type 增加取材能力
      🔧 快速修复: 在项目的向量 provider 模块中补充对应路由

  VT002:
    template: |
      🏛️ 向量事务法官: 检测到未支持的 capsule_kind
      📋 capsule_kind: {capsule_kind}
      💡 建议: 在向量提供方实现中为该 capsule_kind 增加取材能力
      🔧 快速修复: 在项目的向量 provider 模块中补充对应路由

  VT003:
    template: |
      🏛️ 向量事务法官: 检测到事件缺少必填字段
      📌 事件: {event_name}
      📋 缺失字段: {field}
      💡 建议: 发行方必须显式携带 issuer + capsule_kind
      🔧 快速修复: Vector 不允许 DB 反查推断发行方
